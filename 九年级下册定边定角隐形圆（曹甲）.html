<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>定边定角隐形圆动态演示（60°）</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #f0f4ff 0%, #e6f0ff 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            gap: 1.2rem;
            margin: 0;
        }
        .header {
            text-align: center;
            width: 100%;
            max-width: 1000px;
        }
        .header h1 {
            font-size: 2rem;
            color: #1e3a8a;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        .header .author {
            font-size: 1.1rem;
            color: #475569;
            margin-bottom: 0.8rem;
        }
        .header p {
            font-size: 1.1rem;
            color: #475569;
            max-width: 800px;
            margin: 0 auto;
        }
        .canvas-container {
            width: 100%;
            max-width: 1200px;
            height: calc(100vh - 220px); /* 适配屏幕高度，减去头部和控制栏高度 */
            min-height: 400px; /* 最小高度限制 */
            background: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 8px 32px rgba(156, 163, 175, 0.15);
            overflow: hidden;
            position: relative;
        }
        #demoCanvas {
            width: 100%;
            height: 100%;
        }
        .control-panel {
            width: 100%;
            max-width: 900px;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            flex-wrap: wrap;
            padding: 1rem 1.5rem;
            background: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 20px rgba(156, 163, 175, 0.1);
        }
        .control-label {
            white-space: nowrap;
            font-size: 1.05rem;
            color: #334155;
            font-weight: 500;
        }
        .slider-container {
            flex: 1;
            min-width: 220px;
        }
        #cSlider {
            -webkit-appearance: none;
            width: 100%;
            height: 9px;
            border-radius: 4.5px;
            background: #e2e8f0;
            outline: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        #cSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #3b82f6;
            box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3);
            border: 2px solid #ffffff;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #cSlider::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
        }
        #cSlider::-webkit-slider-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.5);
        }
        .angle-indicator {
            min-width: 80px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            color: #1e3a8a;
            background: #eff6ff;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid #dbeafe;
            box-shadow: 0 2px 6px rgba(147, 197, 253, 0.2);
        }
        .info-tooltip {
            position: absolute;
            bottom: 1.5rem;
            right: 1.5rem;
            background: rgba(255, 255, 255, 0.9);
            padding: 0.7rem 1.2rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            font-size: 0.95rem;
            color: #475569;
            border-left: 3px solid #3b82f6;
        }
        /* 响应式调整 */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.6rem;
            }
            .canvas-container {
                height: calc(100vh - 200px);
            }
            .control-panel {
                padding: 0.8rem 1rem;
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>定边定角隐形圆动态演示（定角60°）</h1>
        <div class="author">作者：曹佳</div> <!-- 新增作者姓名 -->
        <p>通过滑动条控制动点C在圆上运动，直观验证：定边AB固定时，∠ACB始终保持60°（圆周角定理应用）</p>
    </div>

    <div class="canvas-container">
        <canvas id="demoCanvas"></canvas>
        <div class="info-tooltip">
            核心原理：同弧所对的圆周角相等
        </div>
    </div>

    <div class="control-panel">
        <label for="cSlider" class="control-label">动点C位置调节：</label>
        <div class="slider-container">
            <input 
                type="range" 
                id="cSlider" 
                min="0" 
                max="360" 
                value="180" 
                step="0.3"
            >
        </div>
        <span id="angleDisplay" class="angle-indicator">180.0°</span>
    </div>

    <script>
        // 核心元素获取
        const canvas = document.getElementById('demoCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('cSlider');
        const angleDisplay = document.getElementById('angleDisplay');

        // 基础配置参数（教学优化）
        const FIXED_ANGLE = 60; // 定角60°
        const AB_LENGTH_RATIO = 0.6; // 定边AB长度占画布宽度的比例
        const DPR = window.devicePixelRatio || 1; // 高清显示适配
        let canvasWidth, canvasHeight;

        // 几何核心参数
        let centerX, centerY;
        let circleRadius, circleCenter;
        let pointA, pointB, pointC;

        // 初始化画布和几何参数
        function init() {
            // 画布尺寸适配（实时获取容器大小）
            const container = canvas.parentElement;
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            
            // 高清画布设置
            canvas.width = canvasWidth * DPR;
            canvas.height = canvasHeight * DPR;
            ctx.scale(DPR, DPR);

            // 画布中心坐标
            centerX = canvasWidth / 2;
            centerY = canvasHeight / 2;

            // 动态计算定边AB长度（适配画布宽度）
            const AB_LENGTH = canvasWidth * AB_LENGTH_RATIO;

            // 隐形圆半径计算（正弦定理：a/sinA = 2R）
            circleRadius = AB_LENGTH / (2 * Math.sin(FIXED_ANGLE * Math.PI / 180));

            // 圆心位置（AB垂直平分线上）
            const distanceFromAB = Math.sqrt(Math.pow(circleRadius, 2) - Math.pow(AB_LENGTH / 2, 2));
            circleCenter = {
                x: centerX,
                y: centerY + distanceFromAB // 圆心在AB下方，圆覆盖AB上下区域
            };

            // 固定点A、B坐标
            pointA = { x: centerX - AB_LENGTH / 2, y: centerY };
            pointB = { x: centerX + AB_LENGTH / 2, y: centerY };

            // 初始点C位置（180°方向）
            pointC = calculatePointC(180);

            // 初始渲染
            render();
        }

        // 核心函数：根据角度计算点C坐标
        function calculatePointC(angleDeg) {
            // 角度转换：滑动条角度→数学坐标系弧度（0°→右侧，逆时针递增）
            const angleRad = (angleDeg - 90) * Math.PI / 180;
            
            // 点C坐标计算（圆的参数方程）
            return {
                x: circleCenter.x + circleRadius * Math.cos(angleRad),
                y: circleCenter.y + circleRadius * Math.sin(angleRad)
            };
        }

        // 绘制隐形圆
        function drawInvisibleCircle() {
            ctx.beginPath();
            ctx.arc(circleCenter.x, circleCenter.y, circleRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
            ctx.lineWidth = 2.5;
            ctx.setLineDash([12, 6]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // 绘制圆心和半径
        function drawCenterAndRadius() {
            // 绘制圆心O
            ctx.fillStyle = '#7c3aed';
            ctx.beginPath();
            ctx.arc(circleCenter.x, circleCenter.y, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 绘制半径OA、OB
            ctx.strokeStyle = 'rgba(124, 58, 237, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(circleCenter.x, circleCenter.y);
            ctx.lineTo(pointA.x, pointA.y);
            ctx.moveTo(circleCenter.x, circleCenter.y);
            ctx.lineTo(pointB.x, pointB.y);
            ctx.stroke();

            // 圆心标签
            ctx.font = '16px "Segoe UI", sans-serif';
            ctx.fillStyle = '#7c3aed';
            ctx.fillText('O（圆心）', circleCenter.x + 12, circleCenter.y - 12);
        }

        // 绘制顶点（A、B、C）
        function drawPoints() {
            // 绘制点A
            drawPoint(pointA, 'A', '#2563eb');
            
            // 绘制点B
            drawPoint(pointB, 'B', '#2563eb');
            
            // 绘制点C（突出显示）
            drawPoint(pointC, 'C', '#dc2626');
        }

        // 单个顶点绘制（带标签和阴影）
        function drawPoint(point, label, color) {
            // 顶点圆点
            ctx.beginPath();
            ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // 顶点标签
            ctx.font = '18px "Segoe UI", sans-serif';
            ctx.fillStyle = '#1e293b';
            ctx.shadowColor = 'transparent'; // 取消标签阴影
            const offsetX = point.x > centerX ? 18 : -35;
            const offsetY = point.y > centerY ? 30 : -15;
            ctx.fillText(label, point.x + offsetX, point.y + offsetY);
        }

        // 绘制线段（AB、AC、BC）
        function drawLines() {
            // 动态计算定边AB长度（适配画布宽度）
            const AB_LENGTH = canvasWidth * AB_LENGTH_RATIO;

            // 绘制定边AB（加粗蓝色）
            ctx.beginPath();
            ctx.moveTo(pointA.x, pointA.y);
            ctx.lineTo(pointB.x, pointB.y);
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = Math.max(4, AB_LENGTH * 0.012); // 线段宽度随AB长度自适应
            ctx.stroke();

            // 绘制线段AC、BC（红色实线）
            ctx.beginPath();
            ctx.moveTo(pointA.x, pointA.y);
            ctx.lineTo(pointC.x, pointC.y);
            ctx.lineTo(pointB.x, pointB.y);
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = Math.max(3, AB_LENGTH * 0.009); // 线段宽度随AB长度自适应
            ctx.stroke();
        }

        // 绘制定角标记（60°）
        function drawAngleMarker() {
            const markerRadius = Math.max(25, canvasWidth * 0.04); // 角度标记半径自适应画布
            const vecA = { x: pointA.x - pointC.x, y: pointA.y - pointC.y };
            const vecB = { x: pointB.x - pointC.x, y: pointB.y - pointC.y };
            
            // 计算向量角度
            const angleA = Math.atan2(vecA.y, vecA.x);
            const angleB = Math.atan2(vecB.y, vecB.x);

            // 绘制角度弧线
            ctx.beginPath();
            ctx.arc(pointC.x, pointC.y, markerRadius, angleA, angleB, angleA > angleB);
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = Math.max(3, canvasWidth * 0.005); // 弧线宽度自适应
            ctx.stroke();

            // 绘制角度数值标签
            const midAngle = (angleA + angleB) / 2;
            const textX = pointC.x + (markerRadius + canvasWidth * 0.03) * Math.cos(midAngle);
            const textY = pointC.y + (markerRadius + canvasWidth * 0.03) * Math.sin(midAngle);
            
            const fontSize = Math.max(18, canvasWidth * 0.025); // 字体大小自适应
            ctx.font = `${fontSize}px "Segoe UI", sans-serif`;
            ctx.fillStyle = '#f97316';
            ctx.fontWeight = '600';
            ctx.fillText(`${FIXED_ANGLE}°`, textX, textY);
        }

        // 绘制教学辅助信息
        function drawInfoPanel() {
            const panelX = canvasWidth * 0.02; // 面板位置自适应画布
            const panelY = canvasHeight * 0.03;
            const lineHeight = Math.max(25, canvasHeight * 0.04); // 行高自适应
            const fontSize = Math.max(14, canvasWidth * 0.015); // 字体大小自适应

            ctx.font = `${fontSize}px "Segoe UI", sans-serif`;
            ctx.fillStyle = '#475569';
            
            const AB_LENGTH = canvasWidth * AB_LENGTH_RATIO;
            ctx.fillText(`定边AB长度：${Math.round(AB_LENGTH)}px`, panelX, panelY);
            ctx.fillText(`定角∠ACB：${FIXED_ANGLE}°（圆周角）`, panelX, panelY + lineHeight);
            ctx.fillText(`隐形圆半径：${Math.round(circleRadius)}px`, panelX, panelY + lineHeight * 2);
            ctx.fillText(`点C坐标：(${Math.round(pointC.x)}, ${Math.round(pointC.y)})`, panelX, panelY + lineHeight * 3);
        }

        // 主渲染函数（分层绘制，确保视觉层次）
        function render() {
            // 清空画布
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // 分层绘制（从背景到前景）
            drawInvisibleCircle();    // 1. 隐形圆（最底层）
            drawCenterAndRadius();   // 2. 圆心和半径
            drawInfoPanel();         // 3. 辅助信息面板
            drawLines();             // 4. 线段（AB、AC、BC）
            drawPoints();            // 5. 顶点（A、B、C）
            drawAngleMarker();       // 6. 角度标记（最上层）
        }

        // 滑动条事件监听（实时响应）
        slider.addEventListener('input', function() {
            const angle = parseFloat(this.value);
            // 实时更新角度显示（保留1位小数）
            angleDisplay.textContent = `${angle.toFixed(1)}°`;
            // 计算新的点C坐标
            pointC = calculatePointC(angle);
            // 重新渲染
            render();
        });

        // 窗口大小变化时重新适配
        window.addEventListener('resize', function() {
            init();
        });

        // 初始化执行
        window.addEventListener('load', init);
    </script>
</body>
</html>