<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>矩形ABCD中BP旋转动态演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h2 {
            margin-bottom: 20px;
            text-align: left;
            font-size: 18px;
            font-weight: normal;
            width: 100%;
            max-width: 800px;
            text-indent: 2em;
        }
        .control-panel {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
            max-width: 800px;
            width: 100%;
        }
        .param-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            margin-bottom: 15px;
            overflow-x: auto;
            padding-bottom: 5px;
        }
        label {
            display: inline-block;
            width: 90px;
            white-space: nowrap;
            font-size: 14px;
        }
        input[type="number"] {
            width: 70px;
            padding: 6px 4px;
            text-align: center;
            -moz-appearance: textfield;
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: inner-spin-button;
            opacity: 1;
            margin: 0;
        }
        input[type="range"] {
            flex: 1;
            min-width: 180px;
            margin: 0 8px;
        }
        button {
            padding: 6px 12px;
            margin: 0 5px;
            cursor: pointer;
            background: #007bff;
            color: #fff;
            border: none;
            border-radius: 8px;
        }
        button:hover {
            background: #0056b3;
        }
        #canvas-container {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 0 auto;
        }
        .btn-group {
            margin-top: 15px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        @media (max-width: 768px) {
            .param-group {
                flex-wrap: wrap;
                overflow-x: hidden;
            }
            label {
                width: 80px;
            }
            input[type="range"] {
                min-width: 140px;
            }
            .btn-group {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <h2>矩形ABCD边长由参数控制，O为矩形对称中心 BP长也由参数控制，求三角形AOP面积最小值</h2>
    
    <div id="canvas-container">
        <canvas id="demoCanvas"></canvas>
    </div>

    <div class="control-panel">
        <div class="param-group">
            <label>AB长度：</label>
            <input type="number" id="abLen" value="6" min="1" step="1">
            <label>BC长度：</label>
            <input type="number" id="bcLen" value="8" min="1" step="1">
            <label>BP长度：</label>
            <input type="number" id="bpLen" value="2" min="1" step="1">
            <label>旋转角度：</label>
            <input type="range" id="rotateAngle" min="0" max="360" value="322">
            <span id="angleValue">322°</span>
        </div>
        <div class="btn-group">
            <button id="applyParam">应用参数</button>
            <button id="resetAll">重置所有</button>
            <button id="drawAuxLine">绘制辅助线</button>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const abLenInput = document.getElementById('abLen');
        const bcLenInput = document.getElementById('bcLen');
        const bpLenInput = document.getElementById('bpLen');
        const rotateAngleInput = document.getElementById('rotateAngle');
        const angleValueSpan = document.getElementById('angleValue');
        const applyParamBtn = document.getElementById('applyParam');
        const resetAllBtn = document.getElementById('resetAll');
        const drawAuxLineBtn = document.getElementById('drawAuxLine');
        const canvas = document.getElementById('demoCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        // 初始参数
        let params = {
            abLen: 6,
            bcLen: 8,
            bpLen: 2,
            angle: 322,
            scale: 1,
            offsetX: 0,
            offsetY: 0
        };

        // 逻辑坐标点
        let points = {
            A: { x: 0, y: 6 },
            B: { x: 0, y: 0 },
            C: { x: 8, y: 0 },
            D: { x: 8, y: 6 },
            P: { x: 0, y: 2 },
            rotateP: { x: -1.4, y: 1.6 },
            O: { x: 4, y: 3 },
            H: { x: 0, y: 0 } // 垂足H
        };

        // 动画状态 & P点运动轨迹
        let isDrawingAux = false;
        let drawProgress = 0; // 0-100 绘制进度
        let showPTrack = false;
        let pTrackPoints = []; // 存储P点运动轨迹坐标

        // 窗口大小变化适配
        window.addEventListener('resize', () => {
            adaptCanvas();
            drawAll();
        });

        // 角度滑块更新 - 同步记录P点轨迹
        rotateAngleInput.addEventListener('input', () => {
            const angle = parseInt(rotateAngleInput.value);
            angleValueSpan.textContent = `${angle}°`;
            params.angle = angle;
            updateRotatePPoint();
            // 记录轨迹点
            if (showPTrack) {
                const pCanvas = toCanvasPoint(points.rotateP);
                pTrackPoints.push({x: pCanvas.x, y: pCanvas.y});
            }
            drawAll();
        });

        // 应用参数按钮点击事件
        applyParamBtn.addEventListener('click', () => {
            const newAB = parseInt(abLenInput.value) || 6;
            const newBC = parseInt(bcLenInput.value) || 8;
            const newBP = parseInt(bpLenInput.value) || 2;
            const newAngle = parseInt(rotateAngleInput.value) || 322;

            params.abLen = newAB;
            params.bcLen = newBC;
            params.bpLen = newBP;
            params.angle = newAngle;

            angleValueSpan.textContent = `${newAngle}°`;

            resetPoints();
            adaptCanvas();
            updateRotatePPoint();
            drawAll();
        });

        // 重置所有按钮点击事件
        resetAllBtn.addEventListener('click', () => {
            abLenInput.value = 6;
            bcLenInput.value = 8;
            bpLenInput.value = 2;
            rotateAngleInput.value = 322;
            angleValueSpan.textContent = '322°';

            params = {
                abLen: 6,
                bcLen: 8,
                bpLen: 2,
                angle: 322,
                scale: 1,
                offsetX: 0,
                offsetY: 0
            };

            isDrawingAux = false;
            drawProgress = 0;
            showPTrack = false;
            pTrackPoints = [];
            resetPoints();
            adaptCanvas();
            updateRotatePPoint();
            drawAll();
        });

        // 绘制辅助线按钮点击事件 - 新增P轨迹功能
        drawAuxLineBtn.addEventListener('click', () => {
            if (isDrawingAux) return;
            isDrawingAux = true;
            drawProgress = 0;
            showPTrack = true;
            // 初始化轨迹点 - 加入当前P点坐标
            const initPCanvas = toCanvasPoint(points.rotateP);
            pTrackPoints = [{x: initPCanvas.x, y: initPCanvas.y}];
            animateAuxLine();
        });

        // 重置逻辑坐标点
        function resetPoints() {
            points.A = { x: 0, y: params.abLen };
            points.B = { x: 0, y: 0 };
            points.C = { x: params.bcLen, y: 0 };
            points.D = { x: params.bcLen, y: params.abLen };
            points.P = { x: 0, y: params.bpLen };
            points.O = { x: params.bcLen / 2, y: params.abLen / 2 };
            // 计算垂足H坐标（向量法）
            calcFootPointH();
        }

        // 计算B到AO的垂足H坐标
        function calcFootPointH() {
            const A = points.A;
            const O = points.O;
            const B = points.B;

            // 向量AO
            const vAO_x = O.x - A.x;
            const vAO_y = O.y - A.y;
            // 向量AB
            const vAB_x = B.x - A.x;
            const vAB_y = B.y - A.y;

            // 投影系数 t
            const dot = vAB_x * vAO_x + vAB_y * vAO_y;
            const lenAO = vAO_x * vAO_x + vAO_y * vAO_y;
            const t = lenAO === 0 ? 0 : dot / lenAO;

            // 垂足H坐标
            points.H.x = A.x + t * vAO_x;
            points.H.y = A.y + t * vAO_y;
        }

        // 更新旋转后的P点
        function updateRotatePPoint() {
            points.rotateP = rotateLogicPoint(points.P, points.B, params.angle);
        }

        // 逻辑点绕中心旋转
        function rotateLogicPoint(point, center, angle) {
            const rad = (angle * Math.PI) / 180;
            const dx = point.x - center.x;
            const dy = point.y - center.y;
            return {
                x: center.x + dx * Math.cos(rad) - dy * Math.sin(rad),
                y: center.y + dx * Math.sin(rad) + dy * Math.cos(rad)
            };
        }

        // 画布自适应
        function adaptCanvas() {
            const containerWidth = canvasContainer.clientWidth - 40;
            const containerHeight = window.innerHeight * 0.4;
            canvas.width = containerWidth;
            canvas.height = containerHeight;

            const logicWidth = params.bcLen * 1.2;
            const logicHeight = params.abLen * 1.2;
            const scaleX = containerWidth / logicWidth;
            const scaleY = containerHeight / logicHeight;
            params.scale = Math.min(scaleX, scaleY) * 0.8;

            params.offsetX = (canvas.width - params.bcLen * params.scale) / 2;
            params.offsetY = (canvas.height - params.abLen * params.scale) / 2;
        }

        // 逻辑坐标转画布坐标
        function toCanvasPoint(logicPoint) {
            return {
                x: params.offsetX + logicPoint.x * params.scale,
                y: params.offsetY + (params.abLen - logicPoint.y) * params.scale
            };
        }

        // 绘制所有图形
        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const A = toCanvasPoint(points.A);
            const B = toCanvasPoint(points.B);
            const C = toCanvasPoint(points.C);
            const D = toCanvasPoint(points.D);
            const rotateP = toCanvasPoint(points.rotateP);
            const O = toCanvasPoint(points.O);
            const H = toCanvasPoint(points.H);

            // 0. 绘制P点运动轨迹虚线
            if (showPTrack && pTrackPoints.length > 1) {
                ctx.beginPath();
                ctx.setLineDash([4, 4]);
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1;
                for(let i=0; i<pTrackPoints.length-1; i++) {
                    ctx.moveTo(pTrackPoints[i].x, pTrackPoints[i].y);
                    ctx.lineTo(pTrackPoints[i+1].x, pTrackPoints[i+1].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // 1. 绘制矩形ABCD
            ctx.beginPath();
            ctx.moveTo(A.x, A.y);
            ctx.lineTo(B.x, B.y);
            ctx.lineTo(C.x, C.y);
            ctx.lineTo(D.x, D.y);
            ctx.closePath();
            ctx.strokeStyle = '#0099ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 2. 绘制旋转后的BP线段
            ctx.beginPath();
            ctx.moveTo(B.x, B.y);
            ctx.lineTo(rotateP.x, rotateP.y);
            ctx.strokeStyle = '#ff9900';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 3. 绘制△AOP
            ctx.beginPath();
            ctx.moveTo(A.x, A.y);
            ctx.lineTo(O.x, O.y);
            ctx.lineTo(rotateP.x, rotateP.y);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 150, 150, 0.7)';
            ctx.fill();
            ctx.strokeStyle = '#ff0000';
            ctx.stroke();

            // 4. 绘制辅助线（根据进度）
            if (drawProgress > 0) {
                // 4.1 绘制O→C 虚线
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                const progressOC = Math.min(drawProgress, 50) / 50;
                const drawX = O.x + (C.x - O.x) * progressOC;
                const drawY = O.y + (C.y - O.y) * progressOC;
                ctx.moveTo(O.x, O.y);
                ctx.lineTo(drawX, drawY);
                ctx.stroke();
                ctx.setLineDash([]);

                // 4.2 绘制B→H 垂线（进度>50后开始）
                if (drawProgress > 50) {
                    const progressBH = Math.min(drawProgress - 50, 50) / 50;
                    const drawHX = B.x + (H.x - B.x) * progressBH;
                    const drawHY = B.y + (H.y - B.y) * progressBH;
                    ctx.beginPath();
                    ctx.setLineDash([3, 3]);
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 1;
                    ctx.moveTo(B.x, B.y);
                    ctx.lineTo(drawHX, drawHY);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // 绘制垂足H
                    if (drawProgress >= 100) {
                        ctx.beginPath();
                        ctx.arc(H.x, H.y, 4, 0, Math.PI * 2);
                        ctx.fillStyle = '#333';
                        ctx.fill();
                        // 绘制H标签
                        ctx.font = 'bold italic 20px Times New Roman';
                        ctx.fillStyle = '#333';
                        ctx.fillText('H', H.x + 8, H.y + 5);
                    }
                }
            }

            // 5. 绘制点和标签
            const drawPoint = (canvasPoint, label, color, position) => {
                ctx.beginPath();
                ctx.arc(canvasPoint.x, canvasPoint.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.font = 'bold italic 24px Times New Roman';
                ctx.fillStyle = '#000';

                let labelX = canvasPoint.x;
                let labelY = canvasPoint.y;
                switch(position) {
                    case 'top':
                        labelX -= ctx.measureText(label).width / 2;
                        labelY -= 15;
                        break;
                    case 'bottom':
                        labelX -= ctx.measureText(label).width / 2;
                        labelY += 25;
                        break;
                    case 'left':
                        labelX -= ctx.measureText(label).width + 15;
                        labelY += 8;
                        break;
                    default:
                        labelX += 15;
                        labelY += 8;
                        break;
                }
                ctx.fillText(label, labelX, labelY);
            };
            drawPoint(A, 'A', '#0000ff', 'top');
            drawPoint(B, 'B', '#0000ff', 'bottom');
            drawPoint(C, 'C', '#0000ff', 'bottom');
            drawPoint(D, 'D', '#0000ff', 'top');
            drawPoint(rotateP, 'P', '#ff9900', 'left');
            drawPoint(O, 'O', '#0099ff', 'right');
        }

        // 辅助线动画函数
        function animateAuxLine() {
            if (drawProgress < 100) {
                drawProgress += 1;
                drawAll();
                requestAnimationFrame(animateAuxLine);
            } else {
                isDrawingAux = false;
            }
        }

        // 初始化
        resetPoints();
        adaptCanvas();
        updateRotatePPoint();
        drawAll();
    </script>
</body>
</html>
