<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二次函数图像动态演示课件</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800 leading-relaxed">
    <div class="max-w-4xl mx-auto bg-white p-5 rounded-lg shadow-md my-5">
        <h1 class="text-3xl font-bold text-center text-gray-700 pb-3 border-b-2 border-blue-500 mb-4">二次函数图像动态演示课件</h1>
        <p class="text-center text-gray-500 mb-6">作者：雷新风</p >
        
        <div class="mb-4">
            <h2 class="text-xl font-semibold text-gray-700 pb-2 border-b-2 border-blue-500 mb-3">一、函数表达式</h2>
            <p>二次函数的一般形式为：<code class="bg-gray-100 px-2 py-1 rounded">y = ax² + bx + c</code></p >
            <p>其中，a、b、c为常数，且a ≠ 0。</p >
        </div>
        
        <div class="mb-4">
            <h2 class="text-xl font-semibold text-gray-700 pb-2 border-b-2 border-blue-500 mb-3">二、参数调整</h2>
            <div class="flex flex-wrap gap-5">
                <div class="flex items-center">
                    <label for="a" class="w-12">a = </label>
                    <input type="range" id="a" min="-2" max="2" value="1" step="0.1" class="w-40 mr-2">
                    <span id="aValue">1</span>
                </div>
                <div class="flex items-center">
                    <label for="b" class="w-12">b = </label>
                    <input type="range" id="b" min="-10" max="10" value="0" step="0.5" class="w-40 mr-2">
                    <span id="bValue">0</span>
                </div>
                <div class="flex items-center">
                    <label for="c" class="w-12">c = </label>
                    <input type="range" id="c" min="-10" max="10" value="0" step="0.5" class="w-40 mr-2">
                    <span id="cValue">0</span>
                </div>
            </div>
            <!-- 语音讲解按钮 -->
            <button id="voiceBtn" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">
                播放语音讲解
            </button>
            <!-- 新增状态提示文本 -->
            <p id="voiceStatus" class="mt-2 text-sm text-gray-500 hidden"></p >
        </div>
        
        <div class="mb-4">
            <h2 class="text-xl font-semibold text-gray-700 pb-2 border-b-2 border-blue-500 mb-3">三、图像绘制</h2>
            <div class="relative w-full h-[400px] border border-gray-300 rounded bg-white overflow-hidden">
                <canvas id="graphCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
            </div>
        </div>
        
        <div class="mb-4">
            <h2 class="text-xl font-semibold text-gray-700 pb-2 border-b-2 border-blue-500 mb-3">四、函数性质</h2>
            <div id="properties" class="pl-5">
                <!-- 函数性质将通过JavaScript动态生成 -->
            </div>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const aSlider = document.getElementById('a');
        const bSlider = document.getElementById('b');
        const cSlider = document.getElementById('c');
        const aValue = document.getElementById('aValue');
        const bValue = document.getElementById('bValue');
        const cValue = document.getElementById('cValue');
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const voiceBtn = document.getElementById('voiceBtn');
        const voiceStatus = document.getElementById('voiceStatus'); // 状态提示元素
        
        // 语音讲解文本（简化断句，提升播放流畅度）
        const voiceText = `当a大于零时，抛物线开口向上；小于零时，抛物线开口向下。a的绝对值越大，开口越小；a的绝对值越小，开口越大。a、b同号时，对称轴在y轴左侧；a、b异号时，对称轴在y轴右侧，简称左同右异。特别的，当b等于零时，对称轴是y轴。当c大于零时，抛物线与y轴交于正半轴；c等于零时，抛物线经过原点；c小于零时，交于负半轴。当德尔塔大于零时，抛物线与x轴有两个交点；德尔塔等于零时，只有一个交点，顶点在x轴上；德尔塔小于零时，没有交点。`;
        
        // 修复：语音播放核心函数（兼容浏览器差异）
        function playVoice() {
            // 1. 检查浏览器是否支持语音合成
            if (!('speechSynthesis' in window)) {
                showStatus('当前浏览器不支持语音合成功能，请使用Chrome、Edge等现代浏览器', 'text-red-500');
                return;
            }
            
            // 2. 停止正在播放的语音
            window.speechSynthesis.cancel();
            
            // 3. 创建语音实例（优化参数设置）
            const speech = new SpeechSynthesisUtterance();
            speech.text = voiceText;
            speech.lang = 'zh-CN'; // 强制中文语音
            speech.rate = 0.9; // 降低播放速度，提升清晰度
            speech.pitch = 1.1; // 微调音调，更自然
            speech.volume = 1; // 最大音量
            
            // 4. 绑定事件监听（修复状态反馈）
            speech.onstart = () => {
                voiceBtn.disabled = true; // 防止重复点击
                voiceBtn.textContent = '正在播放...';
                showStatus('语音讲解播放中...', 'text-green-500');
            };
            
            speech.onend = () => {
                voiceBtn.disabled = false;
                voiceBtn.textContent = '播放语音讲解';
                showStatus('语音讲解播放完成', 'text-gray-500');
                // 3秒后隐藏状态提示
                setTimeout(() => voiceStatus.classList.add('hidden'), 3000);
            };
            
            speech.onerror = (error) => {
                voiceBtn.disabled = false;
                voiceBtn.textContent = '播放语音讲解';
                showStatus(`播放失败：${error.message}`, 'text-red-500');
            };
            
            // 5. 播放语音（修复调用时机）
            setTimeout(() => {
                window.speechSynthesis.speak(speech);
            }, 100);
        }
        
        // 状态提示辅助函数
        function showStatus(text, className) {
            voiceStatus.textContent = text;
            voiceStatus.className = `mt-2 text-sm ${className}`;
            voiceStatus.classList.remove('hidden');
        }
        
        // 修复：确保DOM加载完成后绑定事件
        document.addEventListener('DOMContentLoaded', () => {
            voiceBtn.addEventListener('click', playVoice);
        });
        
        // 画布相关函数（保持不变）
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawGraph();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        aSlider.addEventListener('input', function() {
            aValue.textContent = this.value;
            drawGraph();
        });
        
        bSlider.addEventListener('input', function() {
            bValue.textContent = this.value;
            drawGraph();
        });
        
        cSlider.addEventListener('input', function() {
            cValue.textContent = this.value;
            drawGraph();
        });
        
        function drawGraph() {
            const a = parseFloat(aSlider.value);
            const b = parseFloat(bSlider.value);
            const c = parseFloat(cSlider.value);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 30;
            
            // 绘制坐标轴
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.strokeStyle = '#000';
            ctx.stroke();
            
            // 绘制x轴刻度
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            for (let x = -10; x <= 10; x++) {
                if (x !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(centerX + x * scale, centerY - 5);
                    ctx.lineTo(centerX + x * scale, centerY + 5);
                    ctx.stroke();
                    ctx.fillText(x, centerX + x * scale, centerY + 20);
                }
            }
            
            // 绘制y轴刻度
            ctx.textAlign = 'left';
            for (let y = -10; y <= 10; y++) {
                if (y !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(centerX - 5, centerY - y * scale);
                    ctx.lineTo(centerX + 5, centerY - y * scale);
                    ctx.stroke();
                    ctx.fillText(y, centerX + 10, centerY - y * scale + 4);
                }
            }
            
            // 绘制抛物线
            const points = [];
            for (let x = -10; x <= 10; x += 0.1) {
                const y = a * x * x + b * x + c;
                points.push({ x, y });
            }
            
            ctx.beginPath();
            points.forEach(({ x, y }, i) => {
                const pixelX = centerX + x * scale;
                const pixelY = centerY - y * scale;
                i === 0 ? ctx.moveTo(pixelX, pixelY) : ctx.lineTo(pixelX, pixelY);
            });
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 绘制顶点
            const vertexX = -b / (2 * a);
            const vertexY = a * vertexX * vertexX + b * vertexX + c;
            const vertexPixelX = centerX + vertexX * scale;
            const vertexPixelY = centerY - vertexY * scale;
            
            ctx.beginPath();
            ctx.arc(vertexPixelX, vertexPixelY, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.fillText(`顶点(${vertexX.toFixed(1)},${vertexY.toFixed(1)})`, vertexPixelX + 10, vertexPixelY - 10);
            
            // 绘制y轴交点
            const yInterceptPixelX = centerX;
            const yInterceptPixelY = centerY - c * scale;
            ctx.beginPath();
            ctx.arc(yInterceptPixelX, yInterceptPixelY, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'green';
            ctx.fill();
            ctx.fillText(`(0,${c.toFixed(1)})`, yInterceptPixelX + 10, yInterceptPixelY - 10);
            
            // 绘制x轴交点
            const discriminant = b * b - 4 * a * c;
            if (discriminant >= 0) {
                const root1 = (-b + Math.sqrt(discriminant)) / (2 * a);
                const root2 = (-b - Math.sqrt(discriminant)) / (2 * a);
                
                const drawRoot = (x) => {
                    const pixelX = centerX + x * scale;
                    ctx.beginPath();
                    ctx.arc(pixelX, centerY, 5, 0, Math.PI * 2);
                    ctx.fillStyle = 'orange';
                    ctx.fill();
                    ctx.fillText(`(${x.toFixed(1)},0)`, pixelX + 10, centerY - 10);
                };
                
                if (discriminant > 0) drawRoot(root1);
                drawRoot(root2);
            }
            
            // 更新函数性质
            const propertiesDiv = document.getElementById('properties');
            let roots = '';
            if (discriminant > 0) {
                const root1 = (-b + Math.sqrt(discriminant)) / (2 * a);
                const root2 = (-b - Math.sqrt(discriminant)) / (2 * a);
                roots = `两个不相等的实数根：x₁ = ${root1.toFixed(2)}, x₂ = ${root2.toFixed(2)}`;
            } else if (discriminant === 0) {
                const root = -b / (2 * a);
                roots = `两个相等的实数根：x = ${root.toFixed(2)}`;
            } else {
                roots = '没有实数根';
            }
            
            propertiesDiv.innerHTML = `
                <p>1. 开口方向：${a > 0 ? '向上' : '向下'}</p >
                <p>2. 顶点坐标：(${vertexX.toFixed(2)}, ${vertexY.toFixed(2)})</p >
                <p>3. 对称轴：x = ${vertexX.toFixed(2)}</p >
                <p>4. 判别式：Δ = ${discriminant.toFixed(2)}</p >
                <p>5. 根的情况：${roots}</p >
            `;
        }
    </script>
</body>
</html>