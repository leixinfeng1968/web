<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>无理数π在数轴上的表示 - 滑动条在图形下方</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #f9fafb; min-height: 100vh; padding: 20px 10px; }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { text-center margin-bottom: 20px; }
        h1 { font-size: 2rem; color: #1f2937; margin-bottom: 8px; }
        .subtitle { font-size: 1.1rem; color: #4b5563; margin-bottom: 4px; }
        .author { font-size: 0.9rem; color: #6b7280; }
        .value-panel { display: flex; justify-content: space-between; max-width: 500px; margin: 0 auto 15px; padding: 8px 16px; background: #f3f4f6; border-radius: 8px; font-size: 14px; border: 1px solid #e5e7eb; }
        .control-group { max-width: 1000px; margin: 20px auto 0; padding: 0 10px; }
        label { display: block; color: #374151; margin-bottom: 6px; font-size: 1rem; }
        input[type="range"] { width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #ef4444; cursor: pointer; }
        .range-desc { display: flex; justify-content: space-between; text-align: center; font-size: 0.8rem; color: #6b7280; margin-top: 6px; }
        canvas { display: block; margin: 0 auto; border: 1px solid #e5e7eb; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); max-width: 100%; height: auto; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>无理数π在数轴上的表示</h1>
            <p class="subtitle">滑动条驱动 | 起始点<span class="text-red-500 font-bold">强制顺时针</span>旋转（画布自适应屏幕）</p>
            <p class="author">作者：黄权锋 | 初中数学教学课件</p>
        </div>
        <div class="value-panel">
            <span>转动角度：<span id="angleVal" class="font-medium text-red-red-500">0°</span></span>
            <span>对应弧度：<span id="radianVal" class="font-medium text-orange-500">0</span></span>
            <span>滚动距离：<span id="distanceVal" class="font-medium text-blue-500">0</span> px</span>
        </div>
        <!-- 先画布，后滑动条 -->
        <canvas id="demoCanvas"></canvas>
        <div class="control-group">
            <label for="rollControl">顺时针旋转角度（0°~360°，拖动实时同步）：</label>
            <input type="range" id="rollControl" min="0" max="360" value="0" step="0.1">
            <div class="range-desc">
                <span>0°（起始点向下指原点）</span>
                <span>180°（起始点向上，对应π）</span>
                <span>360°（起始点回到初始位置，对应2π）</span>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('demoCanvas');
        const ctx = canvas.getContext('2d');
        const rollControl = document.getElementById('rollControl');
        const angleVal = document.getElementById('angleVal');
        const radianVal = document.getElementById('radianVal');
        const distanceVal = document.getElementById('distanceVal');
        
        // 自适应核心配置（基于屏幕宽度动态计算）
        let config = {};
        function initConfig() {
            const screenWidth = window.innerWidth;
            const canvasWidth = Math.max(800, Math.min(screenWidth - 40, 1400));
            const canvasHeight = Math.floor(canvasWidth * 0.4);
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            const scaleRatio = canvasWidth / 1000;
            config = {
                axisY: Math.floor(canvasHeight * 0.75),
                originX: Math.floor(canvasWidth * 0.2),
                circleRadius: Math.floor(40 * scaleRatio),
                scaleInterval: Math.floor(40 * scaleRatio),
                circleInitX: Math.floor(canvasWidth * 0.2),
                circleInitY: Math.floor(canvasHeight * 0.75 - 40 * scaleRatio)
            };
        }
        
        initConfig();
        drawDemo(0);
        window.addEventListener('resize', () => {
            initConfig();
            const currentAngle = parseFloat(rollControl.value);
            drawDemo(currentAngle);
            updateValueDisplay(currentAngle);
        });
        rollControl.addEventListener('input', (e) => {
            const angle = parseFloat(e.target.value);
            drawDemo(angle);
            updateValueDisplay(angle);
        });
        
        function drawDemo(angle) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const radian = angle * Math.PI / 180;
            const rollDistance = config.circleRadius * radian;
            const currentCircleX = config.circleInitX + rollDistance;
            const currentCircleY = config.circleInitY;
            
            drawNumberAxis();
            drawUnitCircle(currentCircleX, currentCircleY);
            drawRadiusLine(currentCircleX, currentCircleY, radian);
            draw2PiMarker();
            drawOrigin();
            drawTangentPoint(currentCircleX);
            drawStartPoint(currentCircleX, currentCircleY, radian);
        }
        
        function drawNumberAxis() {
            const leftX = Math.max(50, config.originX - 100);
            const rightX = Math.min(canvas.width - 50, config.originX + canvas.width * 0.7);
            const piX = config.originX + Math.PI * config.circleRadius;
            const pi2X = config.originX + 2 * Math.PI * config.circleRadius;
            
            ctx.beginPath();
            ctx.moveTo(leftX, config.axisY);
            ctx.lineTo(rightX, config.axisY);
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            drawAxisArrow(rightX, config.axisY, 'right');
            drawAxisArrow(leftX, config.axisY, 'left');
            
            ctx.font = `${Math.floor(12 * (canvas.width / 1000))}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#4b5563';
            
            for (let i = 1; ; i++) {
                const x = config.originX - i * config.scaleInterval;
                if (x < leftX) break;
                drawScaleMark(x, config.axisY);
                ctx.fillText(`-${i}`, x, config.axisY + 20);
            }
            for (let i = 1; ; i++) {
                const x = config.originX + i * config.scaleInterval;
                if (x > rightX) break;
                drawScaleMark(x, config.axisY);
                ctx.fillText(i, x, config.axisY + 20);
            }
            
            if (piX > leftX && piX < rightX) {
                drawScaleMark(piX, config.axisY, 8, '#f97316');
                ctx.fillStyle = '#f97316';
                ctx.fillText('π', piX, config.axisY + 23);
            }
            if (pi2X > leftX && pi2X < rightX) {
                drawScaleMark(pi2X, config.axisY, 10, '#3b82f6');
                ctx.fillStyle = '#3b82f6';
                ctx.fillText('2π', pi2X, config.axisY + 25);
            }
        }
        
        function drawScaleMark(x, y, length = 6, color = '#6b7280') {
            const scaleLength = length * (canvas.width / 1000);
            ctx.beginPath();
            ctx.moveTo(x, y - scaleLength);
            ctx.lineTo(x, y + scaleLength);
            ctx.strokeStyle = color;
            ctx.lineWidth = scaleLength === 10 ? 2 : 1;
            ctx.stroke();
        }
        
        function drawAxisArrow(x, y, direction) {
            const arrowSize = 8 * (canvas.width / 1000);
            ctx.beginPath();
            if (direction === 'right') {
                ctx.moveTo(x, y);
                ctx.lineTo(x - arrowSize, y - arrowSize/2);
                ctx.lineTo(x - arrowSize, y + arrowSize/2);
            } else {
                ctx.moveTo(x, y);
                ctx.lineTo(x + arrowSize, y - arrowSize/2);
                ctx.lineTo(x + arrowSize, y + arrowSize/2);
            }
            ctx.fillStyle = '#1f2937';
            ctx.fill();
        }
        
        function drawUnitCircle(cx, cy) {
            ctx.beginPath();
            ctx.arc(cx, cy, config.circleRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = `${Math.floor(11 * (canvas.width / 1000))}px Arial`;
            ctx.fillStyle = '#ef4444';
            ctx.textAlign = 'left';
            ctx.fillText('r=1', cx + 10, cy + 25);
        }
        
        function drawOrigin() {
            const dotSize = 7 * (canvas.width / 1000);
            ctx.beginPath();
            ctx.arc(config.originX, config.axisY, dotSize, 0, 2 * Math.PI);
            ctx.fillStyle = '#1f2937';
            ctx.fill();
            ctx.font = `${Math.floor(12 * (canvas.width / 1000))}px Arial`;
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';
            ctx.fillText('原点(0)', config.originX, config.axisY + 24);
        }
        
        function drawTangentPoint(cx) {
            const dotSize = 7 * (canvas.width / 1000);
            const tx = cx;
            const ty = config.axisY;
            ctx.beginPath();
            ctx.arc(tx, ty, dotSize, 0, 2 * Math.PI);
            ctx.fillStyle = '#22c55e';
            ctx.fill();
            ctx.font = `${Math.floor(12 * (canvas.width / 1000))}px Arial`;
            ctx.fillStyle = '#22c55e';
            ctx.textAlign = 'center';
            ctx.fillText('切点', tx, ty - 14);
        }
        
        function drawRadiusLine(cx, cy, radian) {
            const clockwiseAngle = Math.PI/2 + radian;
            const sx = cx + config.circleRadius * Math.cos(clockwiseAngle);
            const sy = cy + config.circleRadius * Math.sin(clockwiseAngle);
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(sx, sy);
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawStartPoint(cx, cy, radian) {
            const dotSize = 8 * (canvas.width / 1000);
            const clockwiseAngle = Math.PI/2 + radian;
            const sx = cx + config.circleRadius * Math.cos(clockwiseAngle);
            const sy = cy + config.circleRadius * Math.sin(clockwiseAngle);
            
            ctx.beginPath();
            ctx.arc(sx, sy, dotSize, 0, 2 * Math.PI);
            ctx.fillStyle = '#ef4444';
            ctx.fill();
            const textY = sy > cy ? sy - 14 : sy + 22;
            ctx.font = `${Math.floor(12 * (canvas.width / 1000))}px Arial`;
            ctx.fillStyle = '#ef4444';
            ctx.textAlign = 'center';
            ctx.fillText('起始点', sx, textY);
        }
        
        function draw2PiMarker() {
            const dotSize = 8 * (canvas.width / 1000);
            const pi2X = config.originX + 2 * Math.PI * config.circleRadius;
            if (pi2X > 50 && pi2X < canvas.width - 50) {
                ctx.beginPath();
                ctx.arc(pi2X, config.axisY, dotSize, 0, 2 * Math.PI);
                ctx.fillStyle = '#3b82f6';
                ctx.fill();
                ctx.font = `${Math.floor(12 * (canvas.width / 1000))}px Arial`;
                ctx.fillStyle = '#3b82f6';
                ctx.textAlign = 'center';
                ctx.fillText('2π对应点', pi2X, config.axisY - 14);
            }
        }
        
        function updateValueDisplay(angle) {
            const radian = angle * Math.PI / 180;
            const distance = config.circleRadius * radian;
            angleVal.textContent = `${angle.toFixed(1)}°`;
            radianVal.textContent = `${radian.toFixed(2)}`;
            distanceVal.textContent = `${distance.toFixed(1)}`;
        }
    </script>
</body>
</html>
