<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>无理数π在数轴上的表示 - 作者：黄权锋</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        canvas { 
            display: block; 
            margin: 0 auto; 
            border: 1px solid #e5e7eb; 
            border-radius: 8px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .value-panel { 
            display: flex; 
            justify-content: space-between; 
            max-width: 400px; 
            margin: 0 auto 6px; 
            padding: 6px 12px; 
            background: #f8fafc; 
            border-radius: 6px; 
            font-size: 14px; 
            border: 1px solid #e2e8f0;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center py-8 px-4">
    <div class="text-center mb-6 w-full max-w-4xl">
        <h1 class="text-3xl font-bold text-gray-800">无理数π在数轴上的表示</h1>
        <p class="text-lg text-gray-600 mt-2">单位圆滚动 + 起始点顺时针转动（核心：初始三点重合，一周对应2π）</p>
        <p class="text-sm text-gray-500 mt-1">作者：黄权锋 | 初中数学教学课件</p>
    </div>

    <div class="value-panel text-gray-700">
        <span>转动角度：<span id="angleVal" class="font-medium text-red-500">0°</span></span>
        <span>对应弧度：<span id="radianVal" class="font-medium text-orange-500">0</span></span>
        <span>滚动距离：<span id="distanceVal" class="font-medium text-blue-500">0</span> px</span>
    </div>

    <div class="w-full max-w-4xl mb-6">
        <label for="rollControl" class="block text-gray-700 mb-2">滚动角度控制（0°~360°）：</label>
        <input 
            type="range" 
            id="rollControl" 
            min="0" 
            max="360" 
            value="0" 
            step="0.5"
            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500"
        >
        <div class="flex justify-between text-xs text-gray-500 mt-1">
            <span>0°（起始点=原点=切点，三点完全重合）</span>
            <span>180°（半周，起始点顺时针转至圆上方，对应π）</span>
            <span>360°（一周，起始点落于2π，验证无理数表示）</span>
        </div>
    </div>

    <canvas id="demoCanvas" width="1000" height="400"></canvas>

    <script>
        const canvas = document.getElementById('demoCanvas');
        const ctx = canvas.getContext('2d');
        const rollControl = document.getElementById('rollControl');
        const angleVal = document.getElementById('angleVal');
        const radianVal = document.getElementById('radianVal');
        const distanceVal = document.getElementById('distanceVal');
        
        // 核心配置（强制三点初始坐标完全一致）
        const config = {
            axisY: 300,          // 数轴/原点/切点/起始点 共同Y坐标
            originX: 200,        // 原点/切点/起始点 共同X坐标（0°时）
            circleRadius: 50,    // 单位圆半径（1数学单位）
            scaleInterval: 50,   // 1数学单位=50px
            circleInitX: 200,    // 圆心初始X（=原点X，确保圆下点=原点）
            circleInitY: 250     // 圆心初始Y（=axisY - 半径，确保相切）
        };

        // 初始绘制（0°三点完全重合）
        drawDemo(0);

        rollControl.addEventListener('input', (e) => {
            const angle = parseFloat(e.target.value);
            drawDemo(angle);
            updateValueDisplay(angle);
        });

        // 关键修改：调整绘制层级，确保0°时视觉完全重合
        function drawDemo(angle) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const radian = angle * Math.PI / 180;
            const rollDistance = config.circleRadius * radian;
            const currentCircleX = config.circleInitX + rollDistance;
            const currentCircleY = config.circleInitY;

            // 绘制层级（底层→上层）：数轴→圆→2π点→原点→切点→起始点
            // 原点、切点、起始点按「小→中→大」尺寸叠加，0°时完全覆盖重合
            drawNumberAxis();          // 1. 数轴（最底层）
            drawUnitCircle(currentCircleX, currentCircleY); // 2. 单位圆
            draw2PiMarker();           // 3. 2π点（固定目标）
            drawOrigin();              // 4. 原点（黑7px，底层）
            drawTangentPoint(currentCircleX); // 5. 切点（绿7px，中层，与原点同大，0°重叠）
            drawStartPoint(currentCircleX, currentCircleY, radian); // 6. 起始点（红8px，顶层，覆盖底层）
        }

        // 数轴绘制（不变，规范清晰）
        function drawNumberAxis() {
            const leftX = config.originX - 100;
            const rightX = config.originX + 900;
            const piX = config.originX + Math.PI * config.circleRadius;
            const pi2X = config.originX + 2 * Math.PI * config.circleRadius;

            // 数轴主线
            ctx.beginPath();
            ctx.moveTo(leftX, config.axisY);
            ctx.lineTo(rightX, config.axisY);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 双箭头
            drawAxisArrow(rightX, config.axisY, 'right');
            drawAxisArrow(leftX, config.axisY, 'left');

            // 刻度
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#666';
            // 负刻度
            for (let i = 1; i <= 2; i++) {
                const x = config.originX - i * config.scaleInterval;
                drawScaleMark(x, config.axisY);
                ctx.fillText(`-${i}`, x, config.axisY + 20);
            }
            // 正刻度
            for (let i = 1; ; i++) {
                const x = config.originX + i * config.scaleInterval;
                if (x > rightX) break;
                drawScaleMark(x, config.axisY);
                ctx.fillText(i, x, config.axisY + 20);
            }

            // π标注
            drawScaleMark(piX, config.axisY, 8, '#f97316');
            ctx.fillStyle = '#f97316';
            ctx.fillText('π', piX, config.axisY + 23);

            // 2π标注
            drawScaleMark(pi2X, config.axisY, 10, '#3b82f6');
            ctx.fillStyle = '#3b82f6';
            ctx.fillText('2π', pi2X, config.axisY + 25);
        }

        // 辅助：刻度线（复用逻辑）
        function drawScaleMark(x, y, length = 6, color = '#666') {
            ctx.beginPath();
            ctx.moveTo(x, y - length);
            ctx.lineTo(x, y + length);
            ctx.strokeStyle = color;
            ctx.lineWidth = length === 10 ? 2 : 1;
            ctx.stroke();
        }

        // 辅助：数轴箭头（复用逻辑）
        function drawAxisArrow(x, y, direction) {
            ctx.beginPath();
            if (direction === 'right') {
                ctx.moveTo(x, y);
                ctx.lineTo(x - 10, y - 5);
                ctx.lineTo(x - 10, y + 5);
            } else {
                ctx.moveTo(x, y);
                ctx.lineTo(x + 10, y - 5);
                ctx.lineTo(x + 10, y + 5);
            }
            ctx.fillStyle = '#222';
            ctx.fill();
        }

        // 单位圆（不变，标注半径）
        function drawUnitCircle(cx, cy) {
            ctx.beginPath();
            ctx.arc(cx, cy, config.circleRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 半径辅助线（指向起始点初始位置）
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(config.originX, config.axisY); // 直接指向三点重合处，更精准
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.font = '12px Arial';
            ctx.fillStyle = '#ef4444';
            ctx.textAlign = 'left';
            ctx.fillText('r=1', cx + 10, cy + 25);
        }

        // 原点（黑7px，底层，坐标=0°切点/起始点）
        function drawOrigin() {
            ctx.beginPath();
            ctx.arc(config.originX, config.axisY, 7, 0, 2 * Math.PI);
            ctx.fillStyle = '#222';
            ctx.fill();
            // 文字下移，避免遮挡
            ctx.font = '14px Arial';
            ctx.fillStyle = '#222';
            ctx.textAlign = 'center';
            ctx.fillText('原点(0)', config.originX, config.axisY + 24);
        }

        // 切点（绿7px，中层，0°时坐标=原点，完全重叠）
        function drawTangentPoint(cx) {
            const tx = cx;
            const ty = config.axisY; // 始终在数轴上
            ctx.beginPath();
            ctx.arc(tx, ty, 7, 0, 2 * Math.PI);
            ctx.fillStyle = '#22c55e';
            ctx.fill();
            // 文字上移，避免遮挡
            ctx.font = '14px Arial';
            ctx.fillStyle = '#22c55e';
            ctx.textAlign = 'center';
            ctx.fillText('切点', tx, ty - 14);
        }

        // 起始点（红8px，顶层，0°时坐标=原点/切点，覆盖重叠）
        function drawStartPoint(cx, cy, radian) {
            // 顺时针转动公式（不变，精准）
            const rotateAngle = -Math.PI/2 - radian;
            // 0°时：rotateAngle=-π/2，cos(-π/2)=0，sin(-π/2)=-1 → sx=cx+0=200，sy=cy-50=200？错！改这里！
            // 修正：起始点坐标=圆心+半径×旋转向量，0°时旋转向量指向正下方（原点）
            const sx = cx + config.circleRadius * Math.cos(rotateAngle);
            const sy = cy + config.circleRadius * Math.sin(rotateAngle);
            // 0°时cx=200，cy=250，rotateAngle=-π/2 → sx=200+50×0=200，sy=250+50×(-1)=200？不对！最终修正：
            // 顺时针转动，初始指向正下方（原点），旋转角度应该是 +Math.PI/2（因为canvas坐标系y轴向下）
            const correctRotateAngle = Math.PI/2 - radian; // 核心修正！之前角度方向反了导致位置错
            const correctSx = cx + config.circleRadius * Math.cos(correctRotateAngle);
            const correctSy = cy + config.circleRadius * Math.sin(correctRotateAngle);

            // 红色顶层点（8px，覆盖底层）
            ctx.beginPath();
            ctx.arc(correctSx, correctSy, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#ef4444';
            ctx.fill();
            // 文字根据位置避让，0°时上移
            ctx.font = '14px Arial';
            ctx.fillStyle = '#ef4444';
            ctx.textAlign = 'center';
            const textY = correctSy > cy ? correctSy - 14 : correctSy + 22;
            ctx.fillText('起始点', correctSx, textY);
        }

        // 2π标记点（蓝色8px，固定）
        function draw2PiMarker() {
            const pi2X = config.originX + 2 * Math.PI * config.circleRadius;
            ctx.beginPath();
            ctx.arc(pi2X, config.axisY, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#3b82f6';
            ctx.fill();
            ctx.font = '14px Arial';
            ctx.fillStyle = '#3b82f6';
            ctx.textAlign = 'center';
            ctx.fillText('2π对应点', pi2X, config.axisY - 14);
        }

        // 数值更新（不变，精准）
        function updateValueDisplay(angle) {
            const radian = angle * Math.PI / 180;
            const distance = config.circleRadius * radian;
            angleVal.textContent = `${angle.toFixed(1)}°`;
            radianVal.textContent = `${radian.toFixed(2)}`;
            distanceVal.textContent = `${distance.toFixed(1)}`;
        }
    </script>
</body>
</html>
<!DOCTYPE html><html lang="zh-CN"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>无理数π在数轴上的表示 - 作者：黄权锋</title>    <script src="https://cdn.tailwindcss.com"></script>    <style>        canvas {             display: block;             margin: 0 auto;             border: 1px solid #e5e7eb;             border-radius: 8px;             box-shadow: 0 2px 8px rgba(0,0,0,0.05);        }        .value-panel {             display: flex;             justify-content: space-between;             max-width: 400px;             margin: 0 auto 6px;             padding: 6px 12px;             background: #f8fafc;             border-radius: 6px;             font-size: 14px;             border: 1px solid #e2e8f0;        }    </style></head><body class="bg-gray-50 min-h-screen flex flex-col items-center py-8 px-4">    <div class="text-center mb-6 w-full max-w-4xl">        <h1 class="text-3xl font-bold text-gray-800">无理数π在数轴上的表示</h1>        <p class="text-lg text-gray-600 mt-2">单位圆滚动 + 起始点顺时针转动（核心：初始三点重合，一周对应2π）</p>        <p class="text-sm text-gray-500 mt-1">作者：黄权锋 | 初中数学教学课件</p>    </div>    <div class="value-panel text-gray-700">        <span>转动角度：<span id="angleVal" class="font-medium text-red-500">0°</span></span>        <span>对应弧度：<span id="radianVal" class="font-medium text-orange-500">0</span></span>        <span>滚动距离：<span id="distanceVal" class="font-medium text-blue-500">0</span> px</span>    </div>    <div class="w-full max-w-4xl mb-6">        <label for="rollControl" class="block text-gray-700 mb-2">滚动角度控制（0°~360°）：</label>        <input             type="range"             id="rollControl"             min="0"             max="360"             value="0"             step="0.5"            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500"        >        <div class="flex justify-between text-xs text-gray-500 mt-1">            <span>0°（起始点=原点=切点，三点完全重合）</span>            <span>180°（半周，起始点顺时针转至圆上方，对应π）</span>            <span>360°（一周，起始点落于2π，验证无理数表示）</span>        </div>    </div>    <canvas id="demoCanvas" width="1000" height="400"></canvas>    <script>        const canvas = document.getElementById('demoCanvas');        const ctx = canvas.getContext('2d');        const rollControl = document.getElementById('rollControl');        const angleVal = document.getElementById('angleVal');        const radianVal = document.getElementById('radianVal');        const distanceVal = document.getElementById('distanceVal');                // 核心配置（强制三点初始坐标完全一致）        const config = {            axisY: 300,          // 数轴/原点/切点/起始点 共同Y坐标            originX: 200,        // 原点/切点/起始点 共同X坐标（0°时）            circleRadius: 50,    // 单位圆半径（1数学单位）            scaleInterval: 50,   // 1数学单位=50px            circleInitX: 200,    // 圆心初始X（=原点X，确保圆下点=原点）            circleInitY: 250     // 圆心初始Y（=axisY - 半径，确保相切）        };        // 初始绘制（0°三点完全重合）        drawDemo(0);        rollControl.addEventListener('input', (e) => {            const angle = parseFloat(e.target.value);            drawDemo(angle);            updateValueDisplay(angle);        });        // 关键修改：调整绘制层级，确保0°时视觉完全重合        function drawDemo(angle) {            ctx.clearRect(0, 0, canvas.width, canvas.height);                        const radian = angle * Math.PI / 180;            const rollDistance = config.circleRadius * radian;            const currentCircleX = config.circleInitX + rollDistance;            const currentCircleY = config.circleInitY;            // 绘制层级（底层→上层）：数轴→圆→2π点→原点→切点→起始点            // 原点、切点、起始点按「小→中→大」尺寸叠加，0°时完全覆盖重合            drawNumberAxis();          // 1. 数轴（最底层）            drawUnitCircle(currentCircleX, currentCircleY); // 2. 单位圆            draw2PiMarker();           // 3. 2π点（固定目标）            drawOrigin();              // 4. 原点（黑7px，底层）            drawTangentPoint(currentCircleX); // 5. 切点（绿7px，中层，与原点同大，0°重叠）            drawStartPoint(currentCircleX, currentCircleY, radian); // 6. 起始点（红8px，顶层，覆盖底层）        }        // 数轴绘制（不变，规范清晰）        function drawNumberAxis() {            const leftX = config.originX - 100;            const rightX = config.originX + 900;            const piX = config.originX + Math.PI * config.circleRadius;            const pi2X = config.originX + 2 * Math.PI * config.circleRadius;            // 数轴主线            ctx.beginPath();            ctx.moveTo(leftX, config.axisY);            ctx.lineTo(rightX, config.axisY);            ctx.strokeStyle = '#222';            ctx.lineWidth = 2;            ctx.stroke();            // 双箭头            drawAxisArrow(rightX, config.axisY, 'right');            drawAxisArrow(leftX, config.axisY, 'left');            // 刻度            ctx.font = '14px Arial';            ctx.textAlign = 'center';            ctx.fillStyle = '#666';            // 负刻度            for (let i = 1; i <=